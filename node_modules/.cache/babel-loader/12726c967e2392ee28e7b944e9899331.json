{"ast":null,"code":"// getCaretPosition: return [start, end] as offsets to elem.textContent that\n//   correspond to the selected portion of text\n//   (if start == end, caret is at given position and no text is selected)\nexport function getCaretPosition(elem) {\n  // node_walk: walk the element tree, stop when func(node) returns false\n  function node_walk(node, func) {\n    var result = func(node);\n\n    for (node = node.firstChild; result !== false && node; node = node.nextSibling) result = node_walk(node, func);\n\n    return result;\n  }\n\n  ;\n  var sel = window.getSelection();\n  var cum_length = [0, 0];\n  if (sel.anchorNode == elem) cum_length = [sel.anchorOffset, sel.extentOffset];else {\n    var nodes_to_find = [sel.anchorNode, sel.extentNode];\n    if (!elem.contains(sel.anchorNode) || !elem.contains(sel.extentNode)) return undefined;else {\n      var found = [0, 0];\n      var i;\n      node_walk(elem, function (node) {\n        for (i = 0; i < 2; i++) {\n          if (node == nodes_to_find[i]) {\n            found[i] = true;\n            if (found[i == 0 ? 1 : 0]) return false; // all done\n          }\n        }\n\n        if (node.textContent && !node.firstChild) {\n          for (i = 0; i < 2; i++) {\n            if (!found[i]) cum_length[i] += node.textContent.length;\n          }\n        }\n      });\n      cum_length[0] += sel.anchorOffset;\n      cum_length[1] += sel.extentOffset;\n    }\n  }\n  if (cum_length[0] <= cum_length[1]) return cum_length;\n  return [cum_length[1], cum_length[0]];\n}","map":{"version":3,"names":["getCaretPosition","elem","node_walk","node","func","result","firstChild","nextSibling","sel","window","getSelection","cum_length","anchorNode","anchorOffset","extentOffset","nodes_to_find","extentNode","contains","undefined","found","i","textContent","length"],"sources":["/Users/macbookpro/Documents/my-repository/web/cambridge-anki/extention/src/utils/helpers/getCaretPosition.js"],"sourcesContent":["// getCaretPosition: return [start, end] as offsets to elem.textContent that\n//   correspond to the selected portion of text\n//   (if start == end, caret is at given position and no text is selected)\nexport function getCaretPosition(elem) {\n  // node_walk: walk the element tree, stop when func(node) returns false\n  function node_walk(node, func) {\n    var result = func(node);\n    for(node = node.firstChild; result !== false && node; node = node.nextSibling)\n      result = node_walk(node, func);\n    return result;\n  };\n\n  var sel = window.getSelection();\n  var cum_length = [0, 0];\n\n  if(sel.anchorNode == elem)\n    cum_length = [sel.anchorOffset, sel.extentOffset];\n  else {\n    var nodes_to_find = [sel.anchorNode, sel.extentNode];\n    if(!elem.contains(sel.anchorNode) || !elem.contains(sel.extentNode))\n      return undefined;\n    else {\n      var found = [0,0];\n      var i;\n      node_walk(elem, function(node) {\n        for(i = 0; i < 2; i++) {\n          if(node == nodes_to_find[i]) {\n            found[i] = true;\n            if(found[i == 0 ? 1 : 0])\n              return false; // all done\n          }\n        }\n\n        if(node.textContent && !node.firstChild) {\n          for(i = 0; i < 2; i++) {\n            if(!found[i])\n              cum_length[i] += node.textContent.length;\n          }\n        }\n      });\n      cum_length[0] += sel.anchorOffset;\n      cum_length[1] += sel.extentOffset;\n    }\n  }\n  if(cum_length[0] <= cum_length[1])\n    return cum_length;\n  return [cum_length[1], cum_length[0]];\n}"],"mappings":"AAAA;AACA;AACA;AACA,OAAO,SAASA,gBAAT,CAA0BC,IAA1B,EAAgC;EACrC;EACA,SAASC,SAAT,CAAmBC,IAAnB,EAAyBC,IAAzB,EAA+B;IAC7B,IAAIC,MAAM,GAAGD,IAAI,CAACD,IAAD,CAAjB;;IACA,KAAIA,IAAI,GAAGA,IAAI,CAACG,UAAhB,EAA4BD,MAAM,KAAK,KAAX,IAAoBF,IAAhD,EAAsDA,IAAI,GAAGA,IAAI,CAACI,WAAlE,EACEF,MAAM,GAAGH,SAAS,CAACC,IAAD,EAAOC,IAAP,CAAlB;;IACF,OAAOC,MAAP;EACD;;EAAA;EAED,IAAIG,GAAG,GAAGC,MAAM,CAACC,YAAP,EAAV;EACA,IAAIC,UAAU,GAAG,CAAC,CAAD,EAAI,CAAJ,CAAjB;EAEA,IAAGH,GAAG,CAACI,UAAJ,IAAkBX,IAArB,EACEU,UAAU,GAAG,CAACH,GAAG,CAACK,YAAL,EAAmBL,GAAG,CAACM,YAAvB,CAAb,CADF,KAEK;IACH,IAAIC,aAAa,GAAG,CAACP,GAAG,CAACI,UAAL,EAAiBJ,GAAG,CAACQ,UAArB,CAApB;IACA,IAAG,CAACf,IAAI,CAACgB,QAAL,CAAcT,GAAG,CAACI,UAAlB,CAAD,IAAkC,CAACX,IAAI,CAACgB,QAAL,CAAcT,GAAG,CAACQ,UAAlB,CAAtC,EACE,OAAOE,SAAP,CADF,KAEK;MACH,IAAIC,KAAK,GAAG,CAAC,CAAD,EAAG,CAAH,CAAZ;MACA,IAAIC,CAAJ;MACAlB,SAAS,CAACD,IAAD,EAAO,UAASE,IAAT,EAAe;QAC7B,KAAIiB,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAG,CAAf,EAAkBA,CAAC,EAAnB,EAAuB;UACrB,IAAGjB,IAAI,IAAIY,aAAa,CAACK,CAAD,CAAxB,EAA6B;YAC3BD,KAAK,CAACC,CAAD,CAAL,GAAW,IAAX;YACA,IAAGD,KAAK,CAACC,CAAC,IAAI,CAAL,GAAS,CAAT,GAAa,CAAd,CAAR,EACE,OAAO,KAAP,CAHyB,CAGX;UACjB;QACF;;QAED,IAAGjB,IAAI,CAACkB,WAAL,IAAoB,CAAClB,IAAI,CAACG,UAA7B,EAAyC;UACvC,KAAIc,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAG,CAAf,EAAkBA,CAAC,EAAnB,EAAuB;YACrB,IAAG,CAACD,KAAK,CAACC,CAAD,CAAT,EACET,UAAU,CAACS,CAAD,CAAV,IAAiBjB,IAAI,CAACkB,WAAL,CAAiBC,MAAlC;UACH;QACF;MACF,CAfQ,CAAT;MAgBAX,UAAU,CAAC,CAAD,CAAV,IAAiBH,GAAG,CAACK,YAArB;MACAF,UAAU,CAAC,CAAD,CAAV,IAAiBH,GAAG,CAACM,YAArB;IACD;EACF;EACD,IAAGH,UAAU,CAAC,CAAD,CAAV,IAAiBA,UAAU,CAAC,CAAD,CAA9B,EACE,OAAOA,UAAP;EACF,OAAO,CAACA,UAAU,CAAC,CAAD,CAAX,EAAgBA,UAAU,CAAC,CAAD,CAA1B,CAAP;AACD"},"metadata":{},"sourceType":"module"}